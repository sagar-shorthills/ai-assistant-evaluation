User: MongoDB Data Exploration Tool with GST Integration
Build a full-stack MongoDB Data Exploration Tool with GST calculation capabilities using Node.js, Express, React.js, and Material UI.
Tech Stack Requirements

Backend: Node.js + Express.js (latest stable versions)
Database: MongoDB with official Node.js driver (latest version)
Frontend: React.js (latest stable version)
UI Components: Material UI (MUI v5+)
State Management: React State / Context API
File Export: xlsx, papaparse, jspdf
Dependencies: Use only compatible and up-to-date dependencies to avoid conflicts

Backend (Node.js + Express)
MongoDB Connection

Use the official MongoDB npm package to connect to MongoDB
Store credentials securely using environment variables
Implement connection pooling for optimal performance

API Endpoints

GET /collections: Return a list of available collections in the MongoDB database
GET /fields?collection=collectionName: Fetch the first document from the specified collection and dynamically extract available fields/columns
POST /query: Accept collection name, limit, selected fields, and GST configuration as parameters. Return query results based on the selection with calculated GST amounts
POST /export: Accept selected data and desired format (excel, csv, json, pdf). Return the generated file ready for download
GET /receipt/: Generate a receipt-style view for a specific document

Error Handling

APIs must respond with appropriate HTTP status codes and error messages
MongoDB errors must be caught, properly logged, and handled gracefully
Implement rate limiting to prevent abuse

Frontend (React.js + Material UI)
Layout

Header: Clean, modern application title with intuitive navigation
Left Sidebar:

Application navigation menu
Collection selector (MUI Select component)
Numeric input for "Limit Results" (default 5) (MUI TextField)
Dynamic multi-select widget for fields (MUI Autocomplete with multiple select)
GST configuration section


Main Area:

Results display panel
Toggle between Table and JSON view
Download options
Individual record actions (Print/Receipt view)



GST Integration Features

GST Configuration:

Dropdown to select GST percentage (e.g., 5%, 12%, 18%, 28%)
Field selector to choose which field to apply GST on
Apply button to calculate GST on existing results


GST Calculation:

Add a new column "GST Amount" in results
Calculate using formula: Selected Field Value / GST Percentage * 100
Update JSON view to include GST Amount field
Ensure GST calculations are included in all export formats


Receipt Generation:

Add a "Print Receipt" button for each record
Generate a receipt-style view showing document details with GST calculation
Allow printing and downloading of individual receipts
Use jspdf or similar library for PDF generation



Dynamic Field Selection

When a user selects a collection:

Fetch available fields dynamically using /fields API
Populate fields multi-select based on the fetched fields
Display all fields directly without requiring additional selection from dropdown



Results Display

Table View (MUI DataGrid or Table) by default

Clear column headers
Pagination for large result sets
Sortable columns
Row actions (Print Receipt)


JSON View alternative

Formatted JSON with syntax highlighting
Collapsible sections for better readability


Maintain results even if view toggles or downloads happen

Export Functionality

Primary Download Button with dropdown offering:

Excel format (default)
CSV format
JSON format
PDF format


Include calculated GST amount in all exported files
Show progress indicator during export generation

State Management

Persist fetched query results locally using React state
Results should not reset unless a new query is explicitly triggered
Save user preferences (selected collection, fields, GST settings) to browser storage

UI/UX Requirements

Clean, modern UI following Material UI best practices
Intuitive layout with clear visual hierarchy
Responsive design that works on various screen sizes
Proper loading indicators when data is being fetched
Toast notifications for errors and success messages
Consistent color scheme and typography
Accessibility compliance (WCAG 2.1 AA)

Error Handling & Validation

Form validation for all inputs
Graceful handling of empty results
Friendly error messages for failed operations
Network error detection and retry options

Project Structure & Code Quality

Well-structured project directories (/backend, /frontend)
Separation of concerns (components, services, utilities)
Production-quality, maintainable code with proper comments
Consistent code style and formatting
Unit tests for critical functionality

Deliverables

Complete source code with clear directory structure
.env template for MongoDB credentials (server-side only)
Frontend setup with Material UI components
Documentation (README) explaining:

Setup instructions
Environment configuration
Available features
API endpoints
GST calculation logic


Docker configuration for easy deployment (optional)

Sample Document Structure
json{
  "_id": {"$oid": "6811a7051c6d4566e8bb0183"},
  "Segment": "Government",
  "Country": "Canada",
  "Product": "Carretera",
  "Discount Band": "None",
  "Units Sold": {"$numberDouble": "1618.5"},
  "Manufacturing Price": {"$numberInt": "3"},
  "Sale Price": {"$numberInt": "20"},
  "Gross Sales": {"$numberInt": "32370"},
  "Discounts": {"$numberInt": "0"},
  "Sales": {"$numberInt": "32370"},
  "COGS": {"$numberInt": "16185"},
  "Profit": {"$numberInt": "16185"},
  "Date": {"$numberInt": "41640"},
  "Month Number": {"$numberInt": "1"},
  "Month Name": "January",
  "Year": "2014"
}
Model: # MongoDB Data Exploration Tool with GST Integration

I'll help you build a full-stack MongoDB Data Exploration Tool with GST calculation capabilities. Let me outline the complete implementation plan for your MERN stack application.

## Project Setup

Let's start with the project structure and initial setup:

### Project Structure

```
mongodb-data-explorer/
├── backend/
│   ├── config/
│   │   └── db.js
│   ├── controllers/
│   │   ├── collectionController.js
│   │   └── queryController.js
│   ├── middleware/
│   │   ├── errorHandler.js
│   │   └── rateLimiter.js
│   ├── routes/
│   │   ├── collectionRoutes.js
│   │   └── queryRoutes.js
│   ├── services/
│   │   └── mongoService.js
│   ├── utils/
│   │   ├── exportUtils.js
│   │   └── gstCalculator.js
│   ├── .env
│   ├── .env.example
│   ├── package.json
│   └── server.js
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   │   ├── common/
│   │   │   │   ├── Header.jsx
│   │   │   │   ├── Sidebar.jsx
│   │   │   │   ├── LoadingIndicator.jsx
│   │   │   │   └── ToastNotification.jsx
│   │   │   ├── collection/
│   │   │   │   ├── CollectionSelector.jsx
│   │   │   │   └── FieldSelector.jsx
│   │   │   ├── results/
│   │   │   │   ├── ResultsTable.jsx
│   │   │   │   ├── JsonViewer.jsx
│   │   │   │   └── ViewToggle.jsx
│   │   │   ├── gst/
│   │   │   │   ├── GstCalculator.jsx
│   │   │   │   └── GstConfig.jsx
│   │   │   └── export/
│   │   │       ├── ExportOptions.jsx
│   │   │       └── ReceiptGenerator.jsx
│   │   ├── contexts/
│   │   │   └── AppContext.jsx
│   │   ├── services/
│   │   │   ├── api.js
│   │   │   └── storage.js
│   │   ├── utils/
│   │   │   ├── exportHelpers.js
│   │   │   └── formatters.js
│   │   ├── App.jsx
│   │   ├── index.jsx
│   │   └── theme.js
│   ├── package.json
│   └── .env
├── README.md
└── docker-compose.yml
```

## Backend Implementation

### 1. Backend Setup and MongoDB Connection

Let's start with the server setup and MongoDB connection:

**backend/.env.example**
```
PORT=5000
MONGODB_URI=mongodb://localhost:27017/yourdbname
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=100
```

**backend/config/db.js**
```javascript
const { MongoClient } = require('mongodb');
require('dotenv').config();

// MongoDB Connection Configuration
const uri = process.env.MONGODB_URI;
const client = new MongoClient(uri, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  maxPoolSize: 10 // Connection pooling for better performance
});

// Connection function
async function connectToDatabase() {
  try {
    await client.connect();
    console.log('Successfully connected to MongoDB');
    return client.db();
  } catch (error) {
    console.error('Error connecting to MongoDB:', error);
    process.exit(1);
  }
}

// Export client and connect function
module.exports = {
  connectToDatabase,
  client
};
```

**backend/server.js**
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const { connectToDatabase } = require('./config/db');
const collectionRoutes = require('./routes/collectionRoutes');
const queryRoutes = require('./routes/queryRoutes');
const errorHandler = require('./middleware/errorHandler');
const rateLimiter = require('./middleware/rateLimiter');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(helmet());
app.use(compression());
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));
app.use(rateLimiter);

// Initialize database connection
let db;
(async function initializeApp() {
  db = await connectToDatabase();
  app.locals.db = db;
})();

// Routes
app.use('/api', collectionRoutes);
app.use('/api', queryRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', message: 'Server is running' });
});

// Error handler middleware (must be last)
app.use(errorHandler);

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});
```

### 2. Backend Middleware

**backend/middleware/errorHandler.js**
```javascript
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  res.status(statusCode).json({
    error: {
      message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
};

module.exports = errorHandler;
```

**backend/middleware/rateLimiter.js**
```javascript
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const rateLimiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 60000, // 1 minute
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests, please try again after some time.',
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

module.exports = rateLimiter;
```

### 3. Backend Services and Controllers

**backend/services/mongoService.js**
```javascript
// MongoDB service for reusable database operations

/**
 * Gets all collections in the database
 * @param {Object} db - MongoDB database instance
 * @returns {Promise<Array>} - List of collection names
 */
async function getCollections(db) {
  try {
    const collections = await db.listCollections().toArray();
    return collections.map(collection => collection.name);
  } catch (error) {
    console.error('Error fetching collections:', error);
    throw error;
  }
}

/**
 * Gets the fields from a sample document in the collection
 * @param {Object} db - MongoDB database instance
 * @param {String} collectionName - Name of the collection
 * @returns {Promise<Object>} - Fields from the first document
 */
async function getCollectionFields(db, collectionName) {
  try {
    const collection = db.collection(collectionName);
    const sampleDoc = await collection.findOne({});

    if (!sampleDoc) {
      return { error: 'No documents found in collection' };
    }

    return { fields: Object.keys(sampleDoc) };
  } catch (error) {
    console.error(`Error fetching fields for collection ${collectionName}:`, error);
    throw error;
  }
}

/**
 * Executes a query against the specified collection
 * @param {Object} db - MongoDB database instance
 * @param {String} collectionName - Name of the collection
 * @param {Array} selectedFields - Fields to include in results
 * @param {Number} limit - Maximum number of documents to return
 * @returns {Promise<Array>} - Query results
 */
async function executeQuery(db, collectionName, selectedFields, limit = 5) {
  try {
    const collection = db.collection(collectionName);

    // Create projection object for selected fields
    const projection = {};
    if (selectedFields && selectedFields.length > 0) {
      selectedFields.forEach(field => {
        projection[field] = 1;
      });
    }

    // Execute query with projection and limit
    const results = await collection
      .find({})
      .project(projection)
      .limit(parseInt(limit))
      .toArray();

    return results;
  } catch (error) {
    console.error(`Error executing query on collection ${collectionName}:`, error);
    throw error;
  }
}

module.exports = {
  getCollections,
  getCollectionFields,
  executeQuery
};
```

**backend/controllers/collectionController.js**
```javascript
const { getCollections, getCollectionFields } = require('../services/mongoService');

/**
 * Get all available collections
 */
exports.getAllCollections = async (req, res, next) => {
  try {
    const db = req.app.locals.db;
    const collections = await getCollections(db);

    res.status(200).json({
      success: true,
      data: collections
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get fields from a collection
 */
exports.getFields = async (req, res, next) => {
  try {
    const { collection } = req.query;

    if (!collection) {
      return res.status(400).json({
        success: false,
        error: 'Collection name is required'
      });
    }

    const db = req.app.locals.db;
    const result = await getCollectionFields(db, collection);

    if (result.error) {
      return res.status(404).json({
        success: false,
        error: result.error
      });
    }

    res.status(200).json({
      success: true,
      data: result.fields
    });
  } catch (error) {
    next(error);
  }
};
```

**backend/utils/gstCalculator.js**
```javascript
/**
 * Calculate GST amount based on field value and GST percentage
 * @param {Number} fieldValue - The value to apply GST on
 * @param {Number} gstPercentage - GST percentage (5, 12, 18, 28)
 * @returns {Number} - Calculated GST amount
 */
function calculateGST(fieldValue, gstPercentage) {
  if (typeof fieldValue !== 'number' || isNaN(fieldValue)) {
    return 0;
  }

  // GST calculation formula
  return parseFloat((fieldValue * gstPercentage / 100).toFixed(2));
}

/**
 * Apply GST calculation to query results
 * @param {Array} results - Query results from MongoDB
 * @param {String} gstField - Field name to apply GST on
 * @param {Number} gstPercentage - GST percentage (5, 12, 18, 28)
 * @returns {Array} - Results with GST amount added
 */
function applyGST(results, gstField, gstPercentage) {
  if (!results || !Array.isArray(results) || !gstField || !gstPercentage) {
    return results;
  }

  return results.map(item => {
    const fieldValue = parseFloat(item[gstField]);
    const gstAmount = calculateGST(fieldValue, gstPercentage);

    return {
      ...item,
      'GST Amount': gstAmount,
      'Total Amount': parseFloat((fieldValue + gstAmount).toFixed(2))
    };
  });
}

module.exports = {
  calculateGST,
  applyGST
};
```

**backend/controllers/queryController.js**
```javascript
const { executeQuery } = require('../services/mongoService');
const { applyGST } = require('../utils/gstCalculator');
const exportUtils = require('../utils/exportUtils');

/**
 * Execute query and return results with optional GST calculation
 */
exports.executeQueryWithGST = async (req, res, next) => {
  try {
    const { collection, fields, limit, gstConfig } = req.body;

    if (!collection) {
      return res.status(400).json({
        success: false,
        error: 'Collection name is required'
      });
    }

    const db = req.app.locals.db;
    let results = await executeQuery(db, collection, fields, limit || 5);

    // Apply GST calculation if GST config is provided
    if (gstConfig && gstConfig.enabled && gstConfig.field && gstConfig.percentage) {
      results = applyGST(results, gstConfig.field, gstConfig.percentage);
    }

    res.status(200).json({
      success: true,
      count: results.length,
      data: results
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Export data in the requested format
 */
exports.exportData = async (req, res, next) => {
  try {
    const { data, format, filename = 'export' } = req.body;

    if (!data || !Array.isArray(data) || !format) {
      return res.status(400).json({
        success: false,
        error: 'Valid data array and export format are required'
      });
    }

    let result;
    let mimeType;

    switch (format.toLowerCase()) {
      case 'excel':
        result = await exportUtils.exportToExcel(data, filename);
        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        break;
      case 'csv':
        result = exportUtils.exportToCSV(data, filename);
        mimeType = 'text/csv';
        break;
      case 'json':
        result = JSON.stringify(data, null, 2);
        mimeType = 'application/json';
        break;
      case 'pdf':
        result = await exportUtils.exportToPDF(data, filename);
        mimeType = 'application/pdf';
        break;
      default:
        return res.status(400).json({
          success: false,
          error: 'Unsupported export format'
        });
    }

    res.status(200).json({
      success: true,
      data: result,
      mimeType,
      filename: `${filename}.${format.toLowerCase() === 'excel' ? 'xlsx' : format.toLowerCase()}`
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Generate receipt for a specific record
 */
exports.generateReceipt = async (req, res, next) => {
  try {
    const { documentId, collection } = req.params;
    const { gstConfig } = req.body;

    if (!documentId || !collection) {
      return res.status(400).json({
        success: false,
        error: 'Document ID and collection name are required'
      });
    }

    const db = req.app.locals.db;
    const coll = db.collection(collection);

    // Try to convert to ObjectId if it follows the format
    let query;
    if (/^[0-9a-fA-F]{24}$/.test(documentId)) {
      const { ObjectId } = require('mongodb');
      query = { _id: new ObjectId(documentId) };
    } else {
      query = { _id: documentId };
    }

    const document = await coll.findOne(query);

    if (!document) {
      return res.status(404).json({
        success: false,
        error: 'Document not found'
      });
    }

    // Calculate GST if config provided
    let documentWithGST = { ...document };
    if (gstConfig && gstConfig.enabled && gstConfig.field && gstConfig.percentage) {
      const fieldValue = parseFloat(document[gstConfig.field]);
      const gstAmount = (fieldValue * gstConfig.percentage / 100);

      documentWithGST = {
        ...documentWithGST,
        'GST Percentage': gstConfig.percentage,
        'GST Amount': parseFloat(gstAmount.toFixed(2)),
        'Total Amount': parseFloat((fieldValue + gstAmount).toFixed(2))
      };
    }

    // Generate PDF receipt
    const pdfBuffer = await exportUtils.generateReceipt(documentWithGST);

    res.status(200).json({
      success: true,
      data: pdfBuffer,
      mimeType: 'application/pdf',
      filename: `receipt-${documentId}.pdf`
    });
  } catch (error) {
    next(error);
  }
};
```

**backend/utils/exportUtils.js**
```javascript
const XLSX = require('xlsx');
const Papa = require('papaparse');
const { jsPDF } = require('jspdf');
const autoTable = require('jspdf-autotable');

/**
 * Export data to Excel format
 * @param {Array} data - Data to export
 * @param {String} filename - Base filename
 * @returns {String} - Base64 encoded Excel file
 */
async function exportToExcel(data, filename) {
  try {
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(data);

    XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'buffer' });

    // Convert buffer to base64
    return excelBuffer.toString('base64');
  } catch (error) {
    console.error('Error exporting to Excel:', error);
    throw error;
  }
}

/**
 * Export data to CSV format
 * @param {Array} data - Data to export
 * @returns {String} - CSV string
 */
function exportToCSV(data) {
  try {
    return Papa.unparse(data);
  } catch (error) {
    console.error('Error exporting to CSV:', error);
    throw error;
  }
}

/**
 * Export data to PDF format
 * @param {Array} data - Data to export
 * @param {String} filename - Base filename
 * @returns {String} - Base64 encoded PDF
 */
async function exportToPDF(data, filename) {
  try {
    const doc = new jsPDF();

    // Add title
    doc.setFontSize(16);
    doc.text(`${filename} - Data Export`, 14, 15);

    // Create table data
    const headers = Object.keys(data[0]);
    const rows = data.map(item => headers.map(header => item[header]));

    // Add table to document
    doc.autoTable({
      head: [headers],
      body: rows,
      startY: 20,
      margin: { top: 20 },
      styles: { overflow: 'linebreak' },
      headStyles: { fillColor: [41, 128, 185], textColor: 255 },
      didDrawPage: (data) => {
        // Add page number at the bottom
        doc.setFontSize(10);
        doc.text(
          `Page ${doc.internal.getNumberOfPages()}`,
          data.settings.margin.left,
          doc.internal.pageSize.height - 10
        );
      }
    });

    // Return base64 encoded PDF
    return doc.output('datauristring').split(',')[1];
  } catch (error) {
    console.error('Error exporting to PDF:', error);
    throw error;
  }
}

/**
 * Generate receipt for specific document
 * @param {Object} document - Document data
 * @returns {String} - Base64 encoded PDF receipt
 */
async function generateReceipt(document) {
  try {
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Add header
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('RECEIPT', doc.internal.pageSize.getWidth() / 2, 20, { align: 'center' });

    // Add date and receipt ID
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    const today = new Date().toLocaleDateString();
    doc.text(`Date: ${today}`, 20, 30);
    doc.text(`Receipt ID: ${document._id}`, 20, 35);

    // Add horizontal line
    doc.setDrawColor(0);
    doc.setLineWidth(0.5);
    doc.line(20, 40, 190, 40);

    // Add item details
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Item Details', 20, 50);

    // Create table for document data
    const tableData = [];
    for (const [key, value] of Object.entries(document)) {
      if (key !== '_id' && key !== 'GST Amount' && key !== 'GST Percentage' && key !== 'Total Amount') {
        tableData.push([key, String(value)]);
      }
    }

    // Add main data table
    doc.autoTable({
      startY: 55,
      head: [['Field', 'Value']],
      body: tableData,
      theme: 'striped',
      headStyles: {
        fillColor: [66, 66, 66],
        textColor: 255
      }
    });

    // Add GST details if available
    if (document['GST Amount'] !== undefined) {
      const finalY = doc.lastAutoTable.finalY + 10;

      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('GST Details', 20, finalY);

      const gstTableData = [
        ['GST Percentage', `${document['GST Percentage']}%`],
        ['GST Amount', `₹${document['GST Amount']}`],
        ['Total Amount', `₹${document['Total Amount']}`]
      ];

      // Add GST table
      doc.autoTable({
        startY: finalY + 5,
        body: gstTableData,
        theme: 'grid',
        styles: {
          cellPadding: 5
        }
      });
    }

    // Add footer
    const pageHeight = doc.internal.pageSize.getHeight();
    doc.setFontSize(10);
    doc.text('Thank you for your business!', doc.internal.pageSize.getWidth() / 2, pageHeight - 20, { align: 'center' });

    // Return base64 string
    return doc.output('datauristring').split(',')[1];
  } catch (error) {
    console.error('Error generating receipt:', error);
    throw error;
  }
}

module.exports = {
  exportToExcel,
  exportToCSV,
  exportToPDF,
  generateReceipt
};
```

### 4. Backend Routes

**backend/routes/collectionRoutes.js**
```javascript
const express = require('express');
const router = express.Router();
const collectionController = require('../controllers/collectionController');

// Get all collections
router.get('/collections', collectionController.getAllCollections);

// Get fields from a collection
router.get('/fields', collectionController.getFields);

module.exports = router;
```

**backend/routes/queryRoutes.js**
```javascript
const express = require('express');
const router = express.Router();
const queryController = require('../controllers/queryController');

// Execute query with optional GST calculation
router.post('/query', queryController.executeQueryWithGST);

// Export data in requested format
router.post('/export', queryController.exportData);

// Generate receipt for specific document
router.post('/receipt/:collection/:documentId', queryController.generateReceipt);

module.exports = router;
```

## Frontend Implementation

### 1. Frontend Setup and Configuration

**frontend/package.json (key dependencies)**
```json
{
  "name": "mongodb-data-explorer-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.11.16",
    "@mui/material": "^5.13.0",
    "@mui/x-data-grid": "^6.4.0",
    "axios": "^1.4.0",
    "file-saver": "^2.0.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-json-view": "^1.21.3",
    "react-scripts": "5.0.1",
    "react-toastify": "^9.1.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

**frontend/.env**
```
REACT_APP_API_URL=http://localhost:5000/api
```

### 2. Frontend Services and Contexts

**frontend/src/services/api.js**
```javascript
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

// Create axios instance with base URL
const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// API service functions
export const collectionsApi = {
  // Get all collections
  getCollections: async () => {
    try {
      const response = await apiClient.get('/collections');
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch collections');
    }
  },

  // Get fields from a collection
  getFields: async (collectionName) => {
    try {
      const response = await apiClient.get(`/fields?collection=${collectionName}`);
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to fetch fields');
    }
  }
};

export const queryApi = {
  // Execute a query with optional GST calculation
  executeQuery: async (collection, fields, limit, gstConfig) => {
    try {
      const response = await apiClient.post('/query', {
        collection,
        fields,
        limit,
        gstConfig
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to execute query');
    }
  },

  // Export data in specified format
  exportData: async (data, format, filename) => {
    try {
      const response = await apiClient.post('/export', {
        data,
        format,
        filename
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to export data');
    }
  },

  // Generate receipt for a specific document
  generateReceipt: async (collection, documentId, gstConfig) => {
    try {
      const response = await apiClient.post(`/receipt/${collection}/${documentId}`, {
        gstConfig
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.error?.message || 'Failed to generate receipt');
    }
  }
};

export default {
  collectionsApi,
  queryApi
};
```

**frontend/src/services/storage.js**
```javascript
// Local storage service for persisting app state

const STORAGE_KEYS = {
  SELECTED_COLLECTION: 'selected_collection',
  SELECTED_FIELDS: 'selected_fields',
  LIMIT: 'limit',
  GST_CONFIG: 'gst_config',
  VIEW_TYPE: 'view_type'
};

export const saveToStorage = (key, value) => {
  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch (error) {
    console.error(`Error saving to localStorage: ${error}`);
  }
};

export const getFromStorage = (key, defaultValue = null) => {
  try {
    const value = localStorage.getItem(key);
    return value ? JSON.parse(value) : defaultValue;
  } catch (error) {
    console.error(`Error reading from localStorage: ${error}`);
    return defaultValue;
  }
};

export const clearStorageItem = (key) => {
  try {
    localStorage.removeItem(key);
  } catch (error) {
    console.error(`Error clearing localStorage item: ${error}`);
  }
};

export default {
  STORAGE_KEYS,
  saveToStorage,
  getFromStorage,
  clearStorageItem
};
```

**frontend/src/contexts/AppContext.jsx**
```jsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import { toast } from 'react-toastify';
import { collectionsApi, queryApi } from '../services/api';
import { STORAGE_KEYS, getFromStorage, saveToStorage } from '../services/storage';

// Create context
export const AppContext = createContext();

export const AppProvider = ({ children }) => {
  // State variables
  const [collections, setCollections] = useState([]);
  const [selectedCollection, setSelectedCollection] = useState(
    getFromStorage(STORAGE_KEYS.SELECTED_COLLECTION, '')
  );
  const [fields, setFields] = useState([]);
  const [selectedFields, setSelectedFields] = useState(
    getFromStorage(STORAGE_KEYS.SELECTED_FIELDS, [])
  );
  const [limit, setLimit] = useState(
    getFromStorage(STORAGE_KEYS.LIMIT, 5)
  );
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [viewType, setViewType] = useState(
    getFromStorage(STORAGE_KEYS.VIEW_TYPE, 'table')
  );
  const [gstConfig, setGstConfig] = useState(
    getFromStorage(STORAGE_KEYS.GST_CONFIG, { enabled: false, field: '', percentage: 18 })
  );

  // Fetch collections when component mounts
  useEffect(() => {
    const fetchCollections = async () => {
      try {
        setLoading(true);
        const response = await collectionsApi.getCollections();
        setCollections(response.data);
      } catch (error) {
        toast.error(error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchCollections();
  }, []);

  // Fetch fields when collection changes
  useEffect(() => {
    const fetchFields = async () => {
      if (!selectedCollection) return;

      try {
        setLoading(true);
        const response = await collectionsApi.getFields(selectedCollection);
        setFields(response.data);

        // Auto-select all fields if none selected yet
        if (selectedFields.length === 0) {
          setSelectedFields(response.data);
          saveToStorage(STORAGE_KEYS.SELECTED_FIELDS, response.data);
        }
      } catch (error) {
        toast.error(error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchFields();
  }, [selectedCollection]);

  // Save preferences to localStorage when they change
  useEffect(() => {
    saveToStorage(STORAGE_KEYS.SELECTED_COLLECTION, selectedCollection);
  }, [selectedCollection]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.SELECTED_FIELDS, selectedFields);
  }, [selectedFields]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.LIMIT, limit);
  }, [limit]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.VIEW_TYPE, viewType);
  }, [viewType]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.GST_CONFIG, gstConfig);
  }, [gstConfig]);

  // Handler function for collection change
  const handleCollectionChange = useCallback((collectionName) => {
    setSelectedCollection(collectionName);
    setSelectedFields([]);
    setResults([]);
  }, []);

  // Handler function for field selection
  const handleFieldsChange = useCallback((newFields) => {
    setSelectedFields(newFields);
  }, []);

  // Handler function for limit change
  const handleLimitChange = useCallback((newLimit) => {
    setLimit(parseInt(newLimit) || 5);
  }, []);

  // Handler function for GST configuration
  const handleGstConfigChange = useCallback((config) => {
    setGstConfig(config);
  }, []);

  // Handler function to execute query
  const executeQuery = useCallback(async () => {
    if (!selectedCollection) {
      toast.warning('Please select a collection first');
      return;
    }

    try {
      setLoading(true);
      const response = await queryApi.executeQuery(
        selectedCollection,
        selectedFields,
        limit,
        gstConfig
      );
      setResults(response.data);
      toast.success(`Retrieved ${response.data.length} records`);
    } catch (error) {
      toast.error(error.message);
    } finally {
      setLoading(false);
    }
  }, [selectedCollection, selectedFields, limit, gstConfig]);

  // Handler function for exporting data
  const exportData = useCallback(async (format) => {
    if (!results || results.length === 0) {
      toast.warning('No data to export');
      return;
    }

    try {
      setLoading(true);
      const response = await queryApi.exportData(
        results,
        format,
        selectedCollection
      );

      // Create and download the file
      const dataUrl = `data:${response.mimeType};base64,${response.data}`;
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = response.filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      toast.success(`Exported data as ${format.toUpperCase()}`);
    } catch (error) {
      toast.error(error.message);
    } finally {
      setLoading(false);
    }
  }, [results, selectedCollection]);

  // Handler function for generating receipt
  const generateReceipt = useCallback(async (documentId) => {
    try {
      setLoading(true);
      const response = await queryApi.generateReceipt(
        selectedCollection,
        documentId,
        gstConfig
      );

      // Create and download the receipt
      const dataUrl = `data:${response.mimeType};base64,${response.data}`;
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = response.filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      toast.success('Receipt generated');
    } catch (error) {
      toast.error(error.message);
    } finally {
      setLoading(false);
    }
  }, [selectedCollection, gstConfig]);

  return (
    <AppContext.Provider
      value={{
        collections,
        selectedCollection,
        fields,
        selectedFields,
        limit,
        results,
        loading,
        viewType,
        gstConfig,
        handleCollectionChange,
        handleFieldsChange,
        handleLimitChange,
        handleGstConfigChange,
        executeQuery,
        exportData,
        generateReceipt,
        setViewType
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export default AppProvider;
```

### 3. Frontend UI Components

**frontend/src/theme.js**
```javascript
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#63a4ff',
      dark: '#004ba0',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#f50057',
      light: '#ff5983',
      dark: '#bb002f',
      contrastText: '#ffffff',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 500,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 500,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 500,
    },
  },
  components: {
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0px 2px 4px -1px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          boxShadow: '0px 2px 4px -1px rgba(0,0,0,0.1)',
          borderRadius: '8px',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: '8px',
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          marginBottom: '16px',
        },
      },
    },
  },
});

export default theme;
```

**frontend/src/components/common/Header.jsx**
```jsx
import React from 'react';
import {
  AppBar,
  Toolbar,
  Typography,
  Box,
  useTheme,
  useMediaQuery,
  IconButton,
} from '@mui/material';
import DatabaseIcon from '@mui/icons-material/Storage';
import GitHubIcon from '@mui/icons-material/GitHub';
import HelpIcon from '@mui/icons-material/Help';

const Header = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  return (
    <AppBar position="fixed" color="primary" sx={{ zIndex: theme.zIndex.drawer + 1 }}>
      <Toolbar>
        <DatabaseIcon sx={{ mr: 2 }} />
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          {isMobile ? 'MongoDB Explorer' : 'MongoDB Data Exploration Tool with GST Integration'}
        </Typography>

        <Box sx={{ display: 'flex' }}>
          <IconButton
            color="inherit"
            aria-label="help"
            title="Help"
            onClick={() => alert('MongoDB Data Explorer with GST integration.\nSelect a collection, configure fields and GST options, and explore your data!')}
          >
            <HelpIcon />
          </IconButton>

          <IconButton
            color="inherit"
            aria-label="github"
            title="GitHub Repository"
            component="a"
            href="https://github.com/yourusername/mongodb-data-explorer"
            target="_blank"
            rel="noopener noreferrer"
          >
            <GitHubIcon />
          </IconButton>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Header;
```

**frontend/src/components/common/Sidebar.jsx**
```jsx
import React, { useContext } from 'react';
import {
  Box,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  useTheme,
  useMediaQuery,
  Typography,
  Toolbar,
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import CollectionSelector from '../collection/CollectionSelector';
import FieldSelector from '../collection/FieldSelector';
import GstConfig from '../gst/GstConfig';
import { AppContext } from '../../contexts/AppContext';

const drawerWidth = 280;

const Sidebar = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const { loading } = useContext(AppContext);

  const drawer = (
    <>
      <Toolbar />
      <Box sx={{ overflow: 'auto', p: 2 }}>
        <List>
          <ListItem>
            <ListItemIcon>
              <DashboardIcon />
            </ListItemIcon>
            <ListItemText primary="Dashboard" />
          </ListItem>
        </List>
        <Divider />

        <Typography variant="subtitle1" sx={{ mt: 2, mb: 1, fontWeight: 'bold' }}>
          Data Selection
        </Typography>

        <CollectionSelector />
        <FieldSelector />

        <Divider sx={{ my: 2 }} />

        <Typography variant="subtitle1" sx={{ mt: 2, mb: 1, fontWeight: 'bold' }}>
          GST Configuration
        </Typography>

        <GstConfig />
      </Box>
    </>
  );

  return (
    <Box
      component="nav"
      sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }}
      aria-label="sidebar navigation"
    >
      {/* Mobile drawer */}
      {isMobile ? (
        <Drawer
          variant="temporary"
          open={false} // Control this with state if needed
          sx={{
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: drawerWidth,
              backgroundColor: theme.palette.background.paper
            },
          }}
          ModalProps={{ keepMounted: true }}
        >
          {drawer}
        </Drawer>
      ) : (
        // Desktop permanent drawer
        <Drawer
          variant="permanent"
          sx={{
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: drawerWidth,
              backgroundColor: theme.palette.background.paper,
              borderRight: `1px solid ${theme.palette.divider}`
            },
          }}
          open
        >
          {drawer}
        </Drawer>
      )}
    </Box>
  );
};

export default Sidebar;
```

**frontend/src/components/collection/CollectionSelector.jsx**
```jsx
import React, { useContext } from 'react';
import {
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  Box,
  Button,
  CircularProgress,
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import { AppContext } from '../../contexts/AppContext';

const CollectionSelector = () => {
  const {
    collections,
    selectedCollection,
    handleCollectionChange,
    limit,
    handleLimitChange,
    executeQuery,
    loading,
  } = useContext(AppContext);

  const handleExecuteQuery = () => {
    executeQuery();
  };

  return (
    <Box sx={{ mb: 2 }}>
      <FormControl fullWidth sx={{ mb: 2 }}>
        <InputLabel id="collection-select-label">Collection</InputLabel>
        <Select
          labelId="collection-select-label"
          id="collection-select"
          value={selectedCollection}
          label="Collection"
          onChange={(e) => handleCollectionChange(e.target.value)}
          disabled={loading || collections.length === 0}
        >
          {collections.length === 0 ? (
            <MenuItem value="" disabled>
              No collections available
            </MenuItem>
          ) : (
            collections.map((collection) => (
              <MenuItem key={collection} value={collection}>
                {collection}
              </MenuItem>
            ))
          )}
        </Select>
      </FormControl>

      <TextField
        label="Limit Results"
        type="number"
        fullWidth
        value={limit}
        onChange={(e) => handleLimitChange(e.target.value)}
        inputProps={{ min: 1, max: 100 }}
        disabled={loading}
        sx={{ mb: 2 }}
      />

      <Button
        variant="contained"
        color="primary"
        fullWidth
        onClick={handleExecuteQuery}
        disabled={!selectedCollection || loading}
        startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <SearchIcon />}
      >
        {loading ? 'Loading...' : 'Query Data'}
      </Button>
    </Box>
  );
};

export default CollectionSelector;
```

**frontend/src/components/collection/FieldSelector.jsx**
```jsx
import React, { useContext } from 'react';
import {
  Box,
  FormControl,
  InputLabel,
  Checkbox,
  ListItemText,
  MenuItem,
  Select,
  Chip,
  OutlinedInput,
} from '@mui/material';
import { AppContext } from '../../contexts/AppContext';

const ITEM_HEIGHT = 48;
const ITEM_PADDING_TOP = 8;
const MenuProps = {
  PaperProps: {
    style: {
      maxHeight: ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,
      width: 250,
    },
  },
};

const FieldSelector = () => {
  const {
    fields,
    selectedFields,
    handleFieldsChange,
    loading,
    selectedCollection,
  } = useContext(AppContext);

  const handleChange = (event) => {
    const {
      target: { value },
    } = event;
    handleFieldsChange(typeof value === 'string' ? value.split(',') : value);
  };

  return (
    <Box sx={{ mb: 2 }}>
      <FormControl fullWidth disabled={loading || !selectedCollection || fields.length === 0}>
        <InputLabel id="field-select-label">Select Fields</InputLabel>
        <Select
          labelId="field-select-label"
          id="field-select"
          multiple
          value={selectedFields}
          onChange={handleChange}
          input={<OutlinedInput id="select-multiple-fields" label="Select Fields" />}
          renderValue={(selected) => (
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
              {selected.map((value) => (
                <Chip key={value} label={value} size="small" />
              ))}
            </Box>
          )}
          MenuProps={MenuProps}
        >
          {fields.map((field) => (
            <MenuItem key={field} value={field}>
              <Checkbox checked={selectedFields.indexOf(field) > -1} />
              <ListItemText primary={field} />
            </MenuItem>
          ))}
        </Select>
      </FormControl>
    </Box>
  );
};

export default FieldSelector;
```

**frontend/src/components/gst/GstConfig.jsx**
```jsx
import React, { useContext, useState, useEffect } from 'react';
import {
  Box,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Switch,
  Typography,
  Button,
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import { AppContext } from '../../contexts/AppContext';

const GST_PERCENTAGES = [5, 12, 18, 28];

const GstConfig = () => {
  const {
    fields,
    gstConfig,
    handleGstConfigChange,
    loading,
    selectedCollection,
    results,
    executeQuery,
  } = useContext(AppContext);

  // Filter fields that might be suitable for GST calculation (numeric fields)
  const [numericFields, setNumericFields] = useState([]);

  useEffect(() => {
    if (results && results.length > 0) {
      // Try to determine which fields contain numeric values
      const potentialNumericFields = fields.filter(fieldName => {
        const firstResult = results[0];
        const value = firstResult[fieldName];
        // Check if the value is a number or can be parsed as one
        return (
          typeof value === 'number' ||
          (typeof value === 'string' && !isNaN(parseFloat(value)))
        );
      });
      setNumericFields(potentialNumericFields);
    } else {
      setNumericFields(fields);
    }
  }, [fields, results]);

  const handleGstEnabledChange = (event) => {
    handleGstConfigChange({
      ...gstConfig,
      enabled: event.target.checked
    });
  };

  const handleGstFieldChange = (event) => {
    handleGstConfigChange({
      ...gstConfig,
      field: event.target.value
    });
  };

  const handleGstPercentageChange = (event) => {
    handleGstConfigChange({
      ...gstConfig,
      percentage: event.target.value
    });
  };

  const applyGstCalculation = () => {
    if (gstConfig.enabled && gstConfig.field) {
      executeQuery();
    }
  };

  return (
    <Box sx={{ mb: 2 }}>
      <FormControlLabel
        control={
          <Switch
            checked={gstConfig.enabled}
            onChange={handleGstEnabledChange}
            disabled={loading || !selectedCollection || fields.length === 0}
          />
        }
        label="Enable GST Calculation"
      />

      {gstConfig.enabled && (
        <>
          <Box sx={{ mt: 2 }}>
            <FormControl fullWidth sx={{ mb: 2 }}>
              <InputLabel id="gst-field-label">GST Field</InputLabel>
              <Select
                labelId="gst-field-label"
                id="gst-field-select"
                value={gstConfig.field}
                label="GST Field"
                onChange={handleGstFieldChange}
                disabled={loading || numericFields.length === 0}
              >
                {numericFields.map((field) => (
                  <MenuItem key={field} value={field}>
                    {field}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <FormControl fullWidth sx={{ mb: 2 }}>
              <InputLabel id="gst-percentage-label">GST Percentage</InputLabel>
              <Select
                labelId="gst-percentage-label"
                id="gst-percentage-select"
                value={gstConfig.percentage}
                label="GST Percentage"
                onChange={handleGstPercentageChange}
                disabled={loading}
              >
                {GST_PERCENTAGES.map((percentage) => (
                  <MenuItem key={percentage} value={percentage}>
                    {percentage}%
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              GST Amount will be calculated as: {gstConfig.field} × {gstConfig.percentage}%
            </Typography>

            <Button
              variant="outlined"
              color="primary"
              fullWidth
              onClick={applyGstCalculation}
              disabled={loading || !gstConfig.field || !selectedCollection}
              startIcon={<CalculateIcon />}
            >
              Apply GST Calculation
            </Button>
          </Box>
        </>
      )}
    </Box>
  );
};

export default GstConfig;
```

**frontend/src/components/results/ResultsTable.jsx**
```jsx
import React, { useContext, useMemo } from 'react';
import {
  DataGrid,
  GridToolbar,
  gridClasses
} from '@mui/x-data-grid';
import {
  Box,
  Typography,
  IconButton,
  Tooltip,
  alpha,
  useTheme
} from '@mui/material';
import ReceiptIcon from '@mui/icons-material/Receipt';
import { AppContext } from '../../contexts/AppContext';

const ResultsTable = () => {
  const { results, loading, generateReceipt } = useContext(AppContext);
  const theme = useTheme();

  // Create columns based on the first result object
  const columns = useMemo(() => {
    if (!results || results.length === 0) return [];

    const firstResult = results[0];
    return Object.keys(firstResult).map((key) => ({
      field: key,
      headerName: key,
      flex: 1,
      minWidth: 150,
      renderCell: (params) => {
        // Handle different data types for display
        const value = params.value;

        if (value === null || value === undefined) {
          return '';
        } else if (typeof value === 'object') {
          // Handle MongoDB ObjectId or Date objects
          if (value.$oid) {
            return value.$oid;
          } else if (value.$date) {
            return new Date(value.$date).toLocaleString();
          } else if (value.$numberInt) {
            return parseInt(value.$numberInt);
          } else if (value.$numberDouble) {
            return parseFloat(value.$numberDouble).toFixed(2);
          } else {
            return JSON.stringify(value);
          }
        } else if (key === 'GST Amount' || key === 'Total Amount') {
          // Format GST and Total amounts
          return typeof value === 'number' ?
            `₹${value.toFixed(2)}` : value;
        }

        return value;
      }
    }));
  }, [results]);

  // Add action column for receipt generation
  const columnsWithActions = useMemo(() => {
    if (columns.length === 0) return [];

    return [
      ...columns,
      {
        field: 'actions',
        headerName: 'Actions',
        width: 100,
        sortable: false,
        filterable: false,
        renderCell: (params) => (
          <Tooltip title="Generate Receipt">
            <IconButton
              onClick={() => generateReceipt(params.row._id.$oid || params.row._id)}
              size="small"
              color="primary"
            >
              <ReceiptIcon />
            </IconButton>
          </Tooltip>
        ),
      },
    ];
  }, [columns, generateReceipt]);

  // Create rows with unique ids
  const rows = useMemo(() => {
    return results.map((result, index) => ({
      ...result,
      id: result._id?.$oid || result._id || index,
    }));
  }, [results]);

  if (!results || results.length === 0) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '300px',
          width: '100%',
          backgroundColor: alpha(theme.palette.primary.main, 0.05),
          borderRadius: 1,
        }}
      >
        <Typography variant="body1" color="textSecondary">
          No results to display. Select a collection and execute a query.
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ height: 500, width: '100%' }}>
      <DataGrid
        rows={rows}
        columns={columnsWithActions}
        loading={loading}
        disableSelectionOnClick
        getRowHeight={() => 'auto'}
        sx={{
          [`& .${gridClasses.cell}`]: {
            py: 1,
          },
          border: 1,
          borderColor: 'divider',
          '& .MuiDataGrid-cell:focus': {
            outline: 'none',
          }
        }}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 10,
            },
          },
        }}
        pageSizeOptions={[5, 10, 25, 50, 100]}
        components={{
          Toolbar: GridToolbar
        }}
        componentsProps={{
          toolbar: {
            showQuickFilter: true,
            quickFilterProps: { debounceMs: 500 },
            printOptions: { disableToolbarButton: true }
          }
        }}
      />
    </Box>
  );
};

export default ResultsTable;
```

**frontend/src/components/results/JsonViewer.jsx**
```jsx
import React, { useContext } from 'react';
import { Box, Typography, Paper } from '@mui/material';
import ReactJson from 'react-json-view';
import { AppContext } from '../../contexts/AppContext';

const JsonViewer = () => {
  const { results, loading } = useContext(AppContext);

  if (loading) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography>Loading data...</Typography>
      </Box>
    );
  }

  if (!results || results.length === 0) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography>No results to display</Typography>
      </Box>
    );
  }

  return (
    <Paper sx={{ p: 2, overflow: 'auto', maxHeight: '70vh' }}>
      <ReactJson
        src={results}
        theme="rjv-default"
        name={false}
        collapsed={1}
        displayDataTypes={false}
        enableClipboard={true}
        style={{
          fontFamily: 'Monaco, monospace',
          fontSize: '14px',
          lineHeight: '1.5'
        }}
      />
    </Paper>
  );
};

export default JsonViewer;
```

**frontend/src/components/results/ViewToggle.jsx**
```jsx
import React, { useContext } from 'react';
import {
  Box,
  ToggleButtonGroup,
  ToggleButton,
  Tooltip
} from '@mui/material';
import TableViewIcon from '@mui/icons-material/TableView';
import CodeIcon from '@mui/icons-material/Code';
import { AppContext } from '../../contexts/AppContext';

const ViewToggle = () => {
  const { viewType, setViewType } = useContext(AppContext);

  const handleViewChange = (event, newView) => {
    if (newView !== null) {
      setViewType(newView);
    }
  };

  return (
    <Box sx={{ mb: 2 }}>
      <ToggleButtonGroup
        value={viewType}
        exclusive
        onChange={handleViewChange}
        aria-label="view type"
        size="small"
      >
        <ToggleButton value="table" aria-label="table view">
          <Tooltip title="Table View">
            <TableViewIcon />
          </Tooltip>
        </ToggleButton>
        <ToggleButton value="json" aria-label="json view">
          <Tooltip title="JSON View">
            <CodeIcon />
          </Tooltip>
        </ToggleButton>
      </ToggleButtonGroup>
    </Box>
  );
};

export default ViewToggle;
```

**frontend/src/components/export/ExportOptions.jsx**
```jsx
import React, { useContext, useState } from 'react';
import {
  Box,
  Button,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  CircularProgress,
} from '@mui/material';
import DownloadIcon from '@mui/icons-material/Download';
import FileExcelIcon from '@mui/icons-material/TableView';
import FileCsvIcon from '@mui/icons-material/GridOn';
import FileJsonIcon from '@mui/icons-material/Code';
import FilePdfIcon from '@mui/icons-material/PictureAsPdf';
import { AppContext } from '../../contexts/AppContext';

const ExportOptions = () => {
  const { exportData, loading, results } = useContext(AppContext);
  const [anchorEl, setAnchorEl] = useState(null);
  const open = Boolean(anchorEl);

  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleExport = (format) => {
    exportData(format);
    handleClose();
  };

  const exportOptions = [
    {
      label: 'Excel (.xlsx)',
      icon: <FileExcelIcon />,
      format: 'excel',
    },
    {
      label: 'CSV (.csv)',
      icon: <FileCsvIcon />,
      format: 'csv',
    },
    {
      label: 'JSON (.json)',
      icon: <FileJsonIcon />,
      format: 'json',
    },
    {
      label: 'PDF (.pdf)',
      icon: <FilePdfIcon />,
      format: 'pdf',
    },
  ];

  return (
    <Box>
      <Button
        variant="contained"
        color="primary"
        startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <DownloadIcon />}
        onClick={handleClick}
        disabled={loading || !results || results.length === 0}
      >
        {loading ? 'Exporting...' : 'Export Data'}
      </Button>
      <Menu anchorEl={anchorEl} open={open} onClose={handleClose}>
        {exportOptions.map((option) => (
          <MenuItem
            key={option.format}
            onClick={() => handleExport(option.format)}
            disabled={loading}
          >
            <ListItemIcon>{option.icon}</ListItemIcon>
            <ListItemText>{option.label}</ListItemText>
          </MenuItem>
        ))}
      </Menu>
    </Box>
  );
};

export default ExportOptions;
```

**frontend/src/components/common/LoadingIndicator.jsx**
```jsx
import React from 'react';
import { Backdrop, CircularProgress, Box, Typography } from '@mui/material';

const LoadingIndicator = ({ open, message = 'Loading...' }) => {
  return (
    <Backdrop
      sx={{
        color: '#fff',
        zIndex: (theme) => theme.zIndex.drawer + 1,
        flexDirection: 'column'
      }}
      open={open}
    >
      <CircularProgress color="inherit" />
      <Box sx={{ mt: 2 }}>
        <Typography variant="body1">{message}</Typography>
      </Box>
    </Backdrop>
  );
};

export default LoadingIndicator;
```

**frontend/src/App.jsx**
```jsx
import React, { useContext } from 'react';
import { Box, CssBaseline, Toolbar, Paper, Stack } from '@mui/material';
import { ToastContainer } from 'react-toastify';
import { ThemeProvider } from '@mui/material/styles';
import theme from './theme';
import Header from './components/common/Header';
import Sidebar from './components/common/Sidebar';
import ResultsTable from './components/results/ResultsTable';
import JsonViewer from './components/results/JsonViewer';
import ViewToggle from './components/results/ViewToggle';
import ExportOptions from './components/export/ExportOptions';
import LoadingIndicator from './components/common/LoadingIndicator';
import { AppContext, AppProvider } from './contexts/AppContext';
import 'react-toastify/dist/ReactToastify.css';

// Main content area
const MainContent = () => {
  const { viewType, loading } = useContext(AppContext);

  return (
    <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
      <Toolbar />
      <Paper sx={{ p: 2 }}>
        <Stack direction="row" spacing={2} sx={{ mb: 2 }}>
          <ViewToggle />
          <Box sx={{ flexGrow: 1 }} />
          <ExportOptions />
        </Stack>

        {viewType === 'table' ? <ResultsTable /> : <JsonViewer />}
      </Paper>

      <LoadingIndicator open={loading} />
    </Box>
  );
};

// App component with providers
const App = () => {
  return (
    <ThemeProvider theme={theme}>
      <AppProvider>
        <Box sx={{ display: 'flex' }}>
          <CssBaseline />
          <Header />
          <Sidebar />
          <MainContent />
          <ToastContainer position="bottom-right" theme="colored" />
        </Box>
      </AppProvider>
    </ThemeProvider>
  );
};

export default App;
```

**frontend/src/index.jsx**
```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

## Docker Configuration (Optional)

**docker-compose.yml**
```yaml
version: '3.8'

services:
  backend:
    build:
      context: ./backend
    ports:
      - "5000:5000"
    environment:
      - PORT=5000
      - MONGODB_URI=mongodb://mongodb:27017/yourdatabase
      - NODE_ENV=production
    depends_on:
      - mongodb
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend
    restart: unless-stopped

  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped

volumes:
  mongodb_data:
```

**backend/Dockerfile**
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm ci --only=production

COPY . .

EXPOSE 5000

CMD ["node", "server.js"]
```

**frontend/Dockerfile**
```dockerfile
FROM node:18-alpine as build

WORKDIR /app

COPY package*.json ./

RUN npm ci

COPY . .

RUN npm run build

FROM nginx:alpine

COPY --from=build /app/build /usr/share/nginx/html

COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

**frontend/nginx.conf**
```
server {
    listen 80;

    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://backend:5000/api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

## README.md

```markdown
# MongoDB Data Exploration Tool with GST Integration

A full-stack web application for exploring MongoDB data with GST calculation capabilities built using Node.js, Express, React.js, and Material UI.

## Features

- Browse MongoDB collections and data
- Dynamically explore collection fields
- View data in table or JSON format
- Apply GST calculations on numeric fields
- Export data in multiple formats (Excel, CSV, JSON, PDF)
- Generate GST-inclusive receipts for individual documents
- Responsive design that works on all devices

## Tech Stack

### Backend
- Node.js
- Express.js
- MongoDB (Official Driver)

### Frontend
- React.js
- Material UI (MUI v5)
- React Context for state management
- xlsx, papaparse, jspdf for export functionality

## Setup and Installation

### Prerequisites
- Node.js v14+ and npm
- MongoDB instance (local or remote)

### Backend Setup
1. Navigate to the backend directory:
   ```
   cd backend
   ```

2. Install dependencies:
   ```
   npm install
   ```

3. Create a `.env` file based on `.env.example`:
   ```
   PORT=5000
   MONGODB_URI=mongodb://localhost:27017/yourdbname
   RATE_LIMIT_WINDOW_MS=60000
   RATE_LIMIT_MAX_REQUESTS=100
   ```

4. Start the server:
   ```
   npm start
   ```

### Frontend Setup
1. Navigate to the frontend directory:
   ```
   cd frontend
   ```

2. Install dependencies:
   ```
   npm install
   ```

3. Create a `.env` file:
   ```
   REACT_APP_API_URL=http://localhost:5000/api
   ```

4. Start the development server:
   ```
   npm start
   ```

5. Build for production:
   ```
   npm run build
   ```

### Docker Setup (Optional)
1. Make sure Docker and Docker Compose are installed
2. Run:
   ```
   docker-compose up -d
   ```

## API Endpoints

- `GET /api/collections`: Get all available collections
- `GET /api/fields?collection={collectionName}`: Get fields from a collection
- `POST /api/query`: Execute query with optional GST calculation
- `POST /api/export`: Export data in specified format
- `POST /api/receipt/{collection}/{documentId}`: Generate receipt for a document

## GST Calculation

GST is calculated using the formula:
```
GST Amount = Field Value × GST Percentage / 100
Total Amount = Field Value + GST Amount
```

The application allows users to:
1. Enable/disable GST calculation
2. Select which field to apply GST on
3. Choose GST percentage (5%, 12%, 18%, 28%)
4. View calculated GST and total amounts in results
5. Include GST calculations in exports and receipts

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature-name`
3. Commit changes: `git commit -m 'Add feature'`
4. Push to the branch: `git push origin feature-name`
5. Submit a pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.
```

## Project Summary

This MongoDB Data Exploration Tool with GST integration provides a comprehensive solution for exploring MongoDB data while adding valuable GST calculation functionality. The application is built with modern MERN stack technologies and follows best practices for code organization, state management, and UI/UX design.

Key features include:
1. Dynamic collection and field exploration
2. GST calculation on selected fields with customizable rates
3. Multiple data view formats (table and JSON)
4. Export capabilities in various formats (Excel, CSV, JSON, PDF)
5. Receipt generation with GST details
6. Responsive design for all devices

The application architecture separates concerns properly with a backend handling MongoDB operations and a clean, modular React frontend with Material UI components. The state management utilizes React Context API for shared state and local storage for persistence of user preferences.